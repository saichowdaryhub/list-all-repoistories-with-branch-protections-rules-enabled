name: Branch Protection Detailed Audit (User Public Repos + Slack)

on:
  workflow_dispatch:   # only run when manually triggered

jobs:
  audit:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    env:
      ORG_NAME: ${{ github.repository_owner }}   # this is your username for personal accounts
      GITHUB_TOKEN: ${{ secrets.BP_PAT }}   # PAT you created
      SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}   # Slack webhook URL
      DEBUG: "true"
      PYTHONUNBUFFERED: "1"

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        run: pip install requests

      - name: Run Branch Protection Audit for User Public Repos
        run: |
          python - <<'EOF'
          import os, requests, time, csv

          ORG = os.getenv("ORG_NAME")  # in your case, this is your GitHub username
          TOKEN = os.getenv("GITHUB_TOKEN")
          SLACK = os.getenv("SLACK_WEBHOOK")
          DEBUG = os.getenv("DEBUG","false").lower()=="true"

          def log(m,l="INFO"): print(f"[{l}] {m}", flush=True)
          def dbg(m):
              if DEBUG: log(m,"DEBUG")

          H = {"Authorization": f"Bearer {TOKEN}", "Accept": "application/vnd.github+json"}

          def get_json(url):
              r = requests.get(url, headers=H, timeout=30)
              dbg(f"GET {url} -> {r.status_code}")
              if r.status_code==200: return r.json()
              if r.status_code==404: return None
              log(f"Failed GET {url} -> {r.status_code}: {r.text[:150]}", "WARN")
              return None

          def list_repos():
              repos, page = [], 1
              while True:
                  data = get_json(f"https://api.github.com/users/{ORG}/repos?per_page=100&page={page}&type=public")
                  if not data: break
                  repos += data
                  if len(data) < 100: break
                  page += 1
              active_repos = [r for r in repos if not r.get("archived", False)]
              return active_repos

          def get_rules(repo, branch):
              return get_json(f"https://api.github.com/repos/{ORG}/{repo}/rules/branches/{branch}") or []

          def try_get_classic_protection(repo, branch):
              url = f"https://api.github.com/repos/{ORG}/{repo}/branches/{branch}/protection"
              r = requests.get(url, headers=H, timeout=30)
              dbg(f"GET {url} -> {r.status_code}")
              if r.status_code == 200:
                  return r.json()
              return None

          # ---- Start
          repos = list_repos()
          log(f"Total active public repositories found: {len(repos)}")
          for r in repos: log(f"â†’ {r['name']}")

          rows = []
          missing, ok = [], []

          # Function to send message to Slack
          def send_to_slack(message):
              if SLACK:
                  requests.post(SLACK, json={"text": message})

          for idx, repo in enumerate(repos, start=1):
              name = repo["name"]
              default_branch = repo.get("default_branch", "main")
              log(f"\n[{idx}/{len(repos)}] Checking repository: {name}")
              log(f"Default branch for {name} is '{default_branch}'")

              # default values
              row = {
                  "Repository": name,
                  "Default Branch": default_branch,
                  "Default branch protection exists": "NO",
                  "Required pull request": "NO",
                  "Required approvals count": "-",
                  "Restrict deletions": "NO",
                  "Block Force pushes": "NO",
              }

              issues = []
              rules = get_rules(name, default_branch)

              if not rules:
                  classic = try_get_classic_protection(name, default_branch)
                  if classic:
                      # mark protection exists
                      row["Default branch protection exists"] = "YES"

                      pr_reviews = classic.get("required_pull_request_reviews")
                      if not pr_reviews:
                          issues.append("Require pull request before merging not enabled")
                      else:
                          cnt = pr_reviews.get("required_approving_review_count", 0)
                          row["Required pull request"] = "YES"
                          row["Required approvals count"] = str(int(cnt)) if cnt else ""
                          if int(cnt) != 2:
                              issues.append(f"Required approvals = {cnt}, expected 2")

                      # classic protection: try to infer deletions/force pushes
                      # if `restrictions` is present, treat deletions as restricted
                      if classic.get("restrictions"):
                          row["Restrict deletions"] = "YES"

                      # classic may include 'allow_force_pushes' flag; if present and False -> blocked
                      if "allow_force_pushes" in classic:
                          if not classic.get("allow_force_pushes"):
                              row["Block Force pushes"] = "YES"
                      else:
                          # unknown: leave as NO
                          pass

                      if issues:
                          log(f"{name}: âŒ Issues (classic) â†’ {', '.join(issues)}")
                          missing.append({"repo": name, "issues": issues})
                      else:
                          log(f"{name}: âœ… All required rules in place (classic)")
                          ok.append(name)
                      rows.append(row)
                      continue

                  log(f"{name}: âŒ No branch protection found on '{default_branch}'")
                  missing.append({
                      "repo": name,
                      "issues": [f"No branch protection found on '{default_branch}'"]
                  })
                  rows.append(row)
                  continue

              # Rules found via Rules API
              row["Default branch protection exists"] = "YES"
              rule_types = {r.get("type"): r for r in rules}

              if "pull_request" in rule_types:
                  row["Required pull request"] = "YES"
              else:
                  issues.append("Require pull request before merging not enabled")

              if "required_approving_review_count" in rule_types:
                  params = rule_types["required_approving_review_count"].get("parameters") or {}
                  count = params.get("required_approving_review_count") or params.get("count")
                  if not count:
                      issues.append("Approvals rule present but count missing")
                  else:
                      row["Required approvals count"] = str(int(count))
                      if int(count) != 2:
                          issues.append(f"Required approvals = {count}, expected 2")
              else:
                  issues.append("Required approving reviews rule missing")

              if "restrict_deletions" in rule_types:
                  row["Restrict deletions"] = "YES"
              else:
                  issues.append("Restrict deletions rule not enabled")

              if "non_fast_forward" in rule_types:
                  row["Block Force pushes"] = "YES"
              else:
                  issues.append("Block force pushes rule not enabled")

              if issues:
                  log(f"{name}: âŒ Issues â†’ {', '.join(issues)}")
                  missing.append({"repo": name, "issues": issues})
              else:
                  log(f"{name}: âœ… All required rules in place")
                  ok.append(name)

              rows.append(row)

          # Format and send results to Slack
          if SLACK:
              try:
                  blocks = [
                      {
                          "type": "header",
                          "text": {
                              "type": "plain_text",
                              "text": "ðŸ”’ Branch Protection Audit Results",
                              "emoji": True
                          }
                      },
                      {
                          "type": "divider"
                      }
                  ]

                  # Add table header as a section
                  blocks.append({
                      "type": "section",
                      "fields": [
                          {"type": "mrkdwn", "text": "*Repository*"},
                          {"type": "mrkdwn", "text": "*Default Branch*"},
                          {"type": "mrkdwn", "text": "*Protection*"},
                          {"type": "mrkdwn", "text": "*PR Required*"},
                          {"type": "mrkdwn", "text": "*Required Approvals*"},
                          {"type": "mrkdwn", "text": "*Restrict Deletions*"},
                          {"type": "mrkdwn", "text": "*Block Force Pushes*"}
                      ]
                  })
                  
                  # Add divider after header
                  blocks.append({"type": "divider"})

                  # Add each repository as a row
                  for r in rows:
                      protection = r["Default branch protection exists"]
                      pr_required = r["Required pull request"]
                      approvals = r["Required approvals count"] if r["Required approvals count"] else "-"
                      restrict_deletions = r["Restrict deletions"]
                      block_force = r["Block Force pushes"]
                      
                      blocks.append({
                          "type": "section",
                          "fields": [
                              {"type": "mrkdwn", "text": f"`{r['Repository']}`"},
                              {"type": "mrkdwn", "text": f"`{r['Default Branch']}`"},
                              {"type": "mrkdwn", "text": protection},
                              {"type": "mrkdwn", "text": pr_required},
                              {"type": "mrkdwn", "text": str(approvals)},
                              {"type": "mrkdwn", "text": restrict_deletions},
                              {"type": "mrkdwn", "text": block_force}
                          ]
                      })

                  # Add divider before summary
                  blocks.append({"type": "divider"})

                  # Add summary section
                  blocks.append({
                      "type": "section",
                      "text": {
                          "type": "mrkdwn",
                          "text": f"ðŸ“Š *Summary*\nâ€¢ Total Repositories: {len(repos)}\nâ€¢ Fully Protected: {len(ok)}\nâ€¢ Need Attention: {len(missing)}"
                      }
                  })

                  # Send to Slack using blocks format
                  r = requests.post(SLACK, json={"blocks": blocks}, timeout=30)
                  log(f"Slack message POST -> {r.status_code}")
                  if r.status_code != 200:
                      log(f"Slack error response: {r.text}", "WARN")
              except Exception as e:
                  log(f"Slack message POST failed: {e}", "WARN")

          # Print results to console for workflow logs
          for r in rows:
              print(f"{r['Repository']}: Protection={r['Default branch protection exists']}, PR Required={r['Required pull request']}, Approvals={r['Required approvals count']}")

          EOF